PCA: Memory Leak Detection using Partial Call-Path Analysis

Data  dependence  analysis  underlies  various  applications  insoftware quality assurance, 
yet existing frameworks/tools for thisanalysis commonly suffer from scalability challenges. 
We present PCA,  a  static  interprocedural  data  dependence  analyzer  forreal-world C programs.
 Leveraging the per-module intermediaterepresentation generated by LLVM,
 PCA performs interproceduralpoints-to and data-flow analyses with a lightweight design. 
 Most of all, it features a partial call path (PCA) analysis that consists of optimization   
 options   to   further   speed   up   data   dependencecomputation. 
 As an example application to show its usefulness, wedemonstratePCAreadily  supports  memory  leak  
 detection,  forwhich it  helps  achieve close  performance and  precision to  
 the same application based on the state-of-the-art value 
 flow analysis.Through the data dependence it computes,PCAcan enable other applications 
 (e.g., impact analysis and taint analysis
With their growing size and complexity, modern software systemsare increasingly 
challenging to check against desired properties(e.g., correctness and security). 
One main approach to this task isto reason about program behaviors with respect to 
how data arecomputed  and  accessed  (e.g.,  in  terms  of  data  dependence) throughout   
the   program.   This   approach,   as   an   underlying technique, supports a range of 
applications in software qualityassurance, such as bug detection and security vulnerability discovery .
There are tools that immediately implement this underlying technique or facilitate such implementations. 
As a recent work,PhASAR[10]    provides    a    generic    framework    for    static interprocedural
 data flow analysis. Yet rather than a specific tool, itoffers building blocks of static analyzers
 (e.g., call graphs, points-toinformation) via a set of APIs that tool developers 
 may use todevelop their own analyzers (e.g., for computing data dependence).Moreover,  
 based  on  the  IFDS/IDE  algorithmic  framework  [9],PhASARtargets  highly  precise  data  
 flow  analyses.  For  large,complex   software   systems,   efficiency   barriers   due   to   its 
 heavyweight  nature  may  not  be  well  paid  off  by  the  level  of
precision  it  offers other  cost-effectiveness  tradeoffs  might  bemore desirable to users.

 While a conventional value flowanalysis would be built on data dependence analysis hence providedata dependence, 
 these state-of-the-art tools focus onsparsevalueflow analysis. 
 They focuses on precise computation of value flowinformation  necessary  
 for  applications  that  need  it,  primarilyapplicable  to  source-sink  problems  such  as  detecting  memorydefects. 
 As a result, these frameworks/tools may not provide thebest cost-effectiveness tradeoffs for 
 particular dependence-basedapplications that do not need the information. Commercial toolslike
 CodeSonar 
 and   Coverity    do   so.   
 Yet   they   areclosed-source hence may not be sufficient for research purposes.
 Therefore, in this paper, we develop PCA, an open-source static interprocedural  
 data  dependence  analysis  tool  that  scales  to industry-scale  C  software  with  a  practical  
 cost-effectiveness tradeoff that complements to what existing alternatives offer 
 (i..e,primarily focusing on precision or not providing desired balance between analysis cost and effectiveness), 
 particularly for solving source-sink problems (e.g., memory leak detection).PCA is built on top of LLVM . 
 It uses the LLVM gold plugin to generatethe intermediate representation (IR) 
 code for each module of agiven input program and computes interprocedural 
 points-to setsusing Andersen algorithm and LLVM basic, built-in analysis capabilities. 
 With such information, it then computes data flowfacts  (e.g.,  reaching  definitions)  using  a  classical  
 fixed-point iterative data-flow analysis algorithm . 
 Finally, it produces the interprocedural data dependence graph. Then in its practical usescenarios,  
 for  both  practitioners  and  researchers,PCA enables different (e.g., data dependence based) 
 application/client analysesand tools through its analysis results.The key merit of PCA is 
 that it offers practical efficiency andscalability for real-world, 
 industry-scale software systems while maintaining a practically useful level of 
 effectiveness in terms ofprecision.  To  reach  this  goal,PCA features  
 apartial call-path analysis(hence this name of our tool) during the interprocedural data  
 dependence  computation,  as  defined  by  two  levels  ofperformance   optimization.   
 First,   in   the   data-flow   analysis algorithm,PCAadopts a user-customizable partial 
 flow sensitivityat function level (i.e., via the call graph) when computing variabledefinitions 
 and uses while referring to the points-to sets computedby the (Andersen) 
 flow-insensitive pointer analysis algorithm.This design substantially reduces the overhead 
 of an otherwise heavy (e.g., flow-sensitive) points-to analysis to save the total timecost  
 of PCA while  compensating  the  precision  loss  from 
 
 An overview of PCA's architecture is given in Figure 1. As the
main PCA's input, the per-module IR files of the program under
analysis are generated using the LLVM gold plugin. Optionally,
users can also provide a function blacklist in which they specify the
functions (e.g., those for debugging purposes only) to be skipped
by the analysis for better efficiency.
With these user inputs, PCA performs its data flow analysis
with optimizations in four phases. In the first phase (LLVM
module linking), PCA links the per-module IR files together and
parses the functions and global variables of the program, and
returns the separated IR for each function and global variable to be
used by other phases. The IR code is the output of the LLVM C
frontend (Clang) applied against the program, where the gold
plugin allows for generating cross-compilation-unit IR code. By
preparing the cross-unit IR, this phase is key for the analyses in
PCA to be interprocedural. In the second phase (points-to
analysis), PCA performs an interprocedural points-to analysis for
global, heap, and local variables, using the Andersens
algorithm [4]. During the third phase (call graph construction),
PCA resolves call targets for direct calls with explicit callees and
for indirect calls according to the points-to sets returned by the
points-to analysis phase. In the last (fourth) phase (data flow
analysis), PCA first constructs the interprocedural control flow
graph (ICFG) from the given call graph and the LLVM instructions
of each function, and then computes data dependence based on the
ICFG and the points-to sets. This last phase produces the
interprocedural data-dependence graph (DDG) as the final PCAs
output. Based on this output, various PCA applications (e.g.,
taint checking, testing) can be developed. Currently, our tool
package includes two applications: PCA-Mem, a static memory
leak detector; and PCA-DIA, a dynamic impact analysis tool. For
demonstration purposes, this paper only elaborates PCA-Mem